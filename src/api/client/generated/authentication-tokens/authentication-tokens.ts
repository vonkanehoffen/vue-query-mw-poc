/**
 * Generated by orval v6.16.0 üç∫
 * Do not edit manually.
 * Liftshare Client API
 * Private API for Liftshare client and partner integrations.
 * OpenAPI spec version: 1.0.0
 */
import { useMutation } from '@tanstack/vue-query';
import type { UseMutationOptions, MutationFunction } from '@tanstack/vue-query';
import type { MaybeRef } from '@tanstack/vue-query/build/lib/types';
import type {
  AdminTokenCreateResponseNnmuhq,
  UnauthorizedResultPecray,
  ValidationExceptionResponseBaseDtoVtrnlzi,
  AdminTokenCreateRequestKiaya,
  AdminTokenRefreshResponseQwnsq,
  AdminTokenRefreshRequestQwdywq,
  AdminTokenTwoFactorCreateResponseDmhny,
  AdminTokenTwoFactorCreateRequestIifgka
} from '.././model';
import { customInstance } from '../../../axiosInstance';

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * Used to generate an admin JWT using Liftshare dashboard user credentials. 
Token is valid for 30 min. 
Token can be refreshed using the refresh token up to 90 days after issue.
 * @summary Generate authentication token
 */
export const postClientToken = (
  adminTokenCreateRequestKiaya: MaybeRef<AdminTokenCreateRequestKiaya>
) => {
  return customInstance<AdminTokenCreateResponseNnmuhq>({
    url: `/client/token`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: adminTokenCreateRequestKiaya
  });
};

export const getPostClientTokenMutationOptions = <
  TError = UnauthorizedResultPecray | ValidationExceptionResponseBaseDtoVtrnlzi,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postClientToken>>,
    TError,
    { data: AdminTokenCreateRequestKiaya },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postClientToken>>,
  TError,
  { data: AdminTokenCreateRequestKiaya },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postClientToken>>,
    { data: AdminTokenCreateRequestKiaya }
  > = (props) => {
    const { data } = props ?? {};

    return postClientToken(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostClientTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof postClientToken>>
>;
export type PostClientTokenMutationBody = AdminTokenCreateRequestKiaya;
export type PostClientTokenMutationError =
  | UnauthorizedResultPecray
  | ValidationExceptionResponseBaseDtoVtrnlzi;

/**
 * @summary Generate authentication token
 */
export const usePostClientToken = <
  TError = UnauthorizedResultPecray | ValidationExceptionResponseBaseDtoVtrnlzi,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postClientToken>>,
    TError,
    { data: AdminTokenCreateRequestKiaya },
    TContext
  >;
}) => {
  const mutationOptions = getPostClientTokenMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Used to refresh an expired admin JWT using a one time refresh token. 
New token is valid for 30 min. 
Token can be refreshed again using the refresh token up to 90 days after issue.
 * @summary Refresh authentication token
 */
export const postClientTokenRefresh = (
  adminTokenRefreshRequestQwdywq: MaybeRef<AdminTokenRefreshRequestQwdywq>
) => {
  return customInstance<AdminTokenRefreshResponseQwnsq>({
    url: `/client/token/refresh`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: adminTokenRefreshRequestQwdywq
  });
};

export const getPostClientTokenRefreshMutationOptions = <
  TError = UnauthorizedResultPecray | ValidationExceptionResponseBaseDtoVtrnlzi,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postClientTokenRefresh>>,
    TError,
    { data: AdminTokenRefreshRequestQwdywq },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postClientTokenRefresh>>,
  TError,
  { data: AdminTokenRefreshRequestQwdywq },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postClientTokenRefresh>>,
    { data: AdminTokenRefreshRequestQwdywq }
  > = (props) => {
    const { data } = props ?? {};

    return postClientTokenRefresh(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostClientTokenRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof postClientTokenRefresh>>
>;
export type PostClientTokenRefreshMutationBody = AdminTokenRefreshRequestQwdywq;
export type PostClientTokenRefreshMutationError =
  | UnauthorizedResultPecray
  | ValidationExceptionResponseBaseDtoVtrnlzi;

/**
 * @summary Refresh authentication token
 */
export const usePostClientTokenRefresh = <
  TError = UnauthorizedResultPecray | ValidationExceptionResponseBaseDtoVtrnlzi,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postClientTokenRefresh>>,
    TError,
    { data: AdminTokenRefreshRequestQwdywq },
    TContext
  >;
}) => {
  const mutationOptions = getPostClientTokenRefreshMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Takes an expired token and a one time two factor code and return a valid token and refresh token if successful.
 * @summary Validate two factor one time code
 */
export const postClientTokenValidateTwoFactor = (
  adminTokenTwoFactorCreateRequestIifgka: MaybeRef<AdminTokenTwoFactorCreateRequestIifgka>
) => {
  return customInstance<AdminTokenTwoFactorCreateResponseDmhny>({
    url: `/client/token/validate-two-factor`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: adminTokenTwoFactorCreateRequestIifgka
  });
};

export const getPostClientTokenValidateTwoFactorMutationOptions = <
  TError = UnauthorizedResultPecray | ValidationExceptionResponseBaseDtoVtrnlzi,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postClientTokenValidateTwoFactor>>,
    TError,
    { data: AdminTokenTwoFactorCreateRequestIifgka },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postClientTokenValidateTwoFactor>>,
  TError,
  { data: AdminTokenTwoFactorCreateRequestIifgka },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postClientTokenValidateTwoFactor>>,
    { data: AdminTokenTwoFactorCreateRequestIifgka }
  > = (props) => {
    const { data } = props ?? {};

    return postClientTokenValidateTwoFactor(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostClientTokenValidateTwoFactorMutationResult = NonNullable<
  Awaited<ReturnType<typeof postClientTokenValidateTwoFactor>>
>;
export type PostClientTokenValidateTwoFactorMutationBody = AdminTokenTwoFactorCreateRequestIifgka;
export type PostClientTokenValidateTwoFactorMutationError =
  | UnauthorizedResultPecray
  | ValidationExceptionResponseBaseDtoVtrnlzi;

/**
 * @summary Validate two factor one time code
 */
export const usePostClientTokenValidateTwoFactor = <
  TError = UnauthorizedResultPecray | ValidationExceptionResponseBaseDtoVtrnlzi,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postClientTokenValidateTwoFactor>>,
    TError,
    { data: AdminTokenTwoFactorCreateRequestIifgka },
    TContext
  >;
}) => {
  const mutationOptions = getPostClientTokenValidateTwoFactorMutationOptions(options);

  return useMutation(mutationOptions);
};
